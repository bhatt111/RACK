uri "http://Turnstile/PropertyDefinitionInference".
import "http://www.w3.org/2000/01/rdf-schema".

// Include the Project Specific Definition Files
import "http://Turnstile/DevelopmentPlan".

// 10/16/2020 : restarted work on this: started with files in master and added in GenerateCSVQueries and RunCSVQueries and deleted GenerateCSV
//		first limit it to just do one class say SYSTEM; originally the column headers I am generating are
// SYSTEM	wasAttributedTo	hasAttribute	producedBy	uniqueIdentifier	provides	dataInsertedBy	invalidatedAtTime	partOf	requires	generatedAtTime
//		the column headers in GIT are
// identifier	partOfId	producedById	providesId	requiresId	dataInsertedById	geneatedAtTime	wasAttributedToId

//		so, I should replace the first column header with 5th column header but it should be called identifier
//		at the moment have not decided on bnodes so ignore it initially
// have SYSTEMTemp and ENTITYTemp and commented Rule GenClassPropStrThing; this writes out for ENTITY, SYSTEM and THING

// Running this file will generate output that can then used to run queries 
// that will generate the csv files for data ingestion, see instructions below.
// Note this is for TurnstileSystem but can be modified to work with any model.

// Rules to generate a ClassProp structure for classes of interest to us.
// One rule each subclass of ENTITY, ACTIVITY, AGENT; but some of these we may want to discard
// 		I am currently discarding COLLECTION.
// Note some csv files are empty: BUILD, CODE_DEVELOPMENT, CODE_GEN, HAZARD_IDENTIFICATION, PERSON
//		REQUIREMENT_DEVELOPMENT, SOFTWAREAGENT, SYSTEM_DEVELOPMENT, TEST_DEVELOPMENT
// I do not have CONFIDENCE_ASSESSMENT, FORMAT.
// The file I have is TEST_RESULT and not TEST_RESULTS.
// In the files I generate, the first column specifies the "object" which is not there in previous manually generated CSV files 
// Note there is no uniqueIdentifier for TEST_EXECUTION.

// For HAZARD.csv generated:
//		In our data, the source can be another Hazard or a System; in existing CSV there are 2 columns to reflect this;
//		as SemTK needs the type info
//		Currently, I have just one column for source which contains both Hazard and System.
//		A better solution would be to have columns 'source' and 'sourceType'.
//		In what I generate, I have columns 'source' and 'wasDerivedFrom'; since 'source' is a type of 'wasDerivedFrom'
//		I should drop 'wasDerivedFrom' column.

// Differences with csv file that were present in Rack V2.
//		first column now is new
//		order of columns is different	

// define a structure where the properties will be stored for a class
ClassProp is a class, 
	described by className with a single value of type class 
	described by propName (note " all the properties with className in the domain") with values of type class
	described by superPropName (note " all the properties that have more specific subproperties") with values of type class.

// temporarily I want to only consider SYSTEM
//SYSTEMTemp is a ClassProp with className SYSTEM.
//ENTITYTemp is a ClassProp with className ENTITY.

 Rule Transitive1 // do I need it?
 if cls1 rdfs:subClassOf cls2
 and cls2 rdfs:subClassOf cls3
 then cls1 rdfs:subClassOf cls3.
 
 Rule Transitive2  
if inst is a cls and 
   cls is a type of cls2
then inst is a cls2.

//// I am dropping COLLECTION 
//Rule GenClassPropStrEntity:
//if xclass has rdfs:subClassOf ENTITY
//and noValue(xclass,rdfs:subClassOf,COLLECTION)
//then there exists a ClassProp with className xclass.
//
//// should I drop ACTIVITY, note it has blank node for "used" property 
//Rule GenClassPropStrActivity:
//if xclass has rdfs:subClassOf ACTIVITY
//then there exists a ClassProp with className xclass.
// 
//Rule GenClassPropStrAgent:
//if xclass has rdfs:subClassOf AGENT
//then there exists a ClassProp with className xclass.

THINGTemp is a ClassProp with className THING.
// I am dropping ATTRIBUTE, COLLECTION, FIELD 
Rule GenClassPropStrThing:
if xclass has rdfs:subClassOf THING
and noValue(xclass,rdfs:subClassOf,ATTRIBUTE)
and noValue(xclass,rdfs:subClassOf,COLLECTION)
and noValue(xclass,rdfs:subClassOf,FIELD)
then there exists a ClassProp with className xclass.

Rule PopulateClassProp0: // gets all direct properties
	if  cp is a ClassProp and cn is className of cp 
		and p has rdfs:domain cn 
		and p has rdfs:range r
//		and print("range of ",p," is ",r)  
	then cp has propName p.

Rule TransitiveClassProp:  // gets all properties from ancestors
    if cp1 is a ClassProp and cp2 is a ClassProp and cp1 != cp2 // get 2 different ClassProp
       and cn1 is className of cp1 and cn2 is className of cp2  // get their className
       and cn1 has rdfs:subClassOf cn2 							// cn1 is a descendant of cn2
       and p2 is a propName of cp2
    then cp1 has propName p2.   

Rule TagSuperProperties: // identifies ancestor properties that are made more specific by other properties
    if cp1 is a ClassProp and cp2 is a ClassProp and cp1 != cp2 // get 2 different ClassProp       
       and cn1 is className of cp1 and cn2 is className of cp2  // get their className     
       and cn1 has rdfs:subClassOf cn2 							// cn1 is a descendant of cn2
       and p1 is a propName of cp1 
       and p1 has rdfs:subPropertyOf p2 						// so "p1 is a type of p2"
       and p1 != p2
       and cp2 has propName p2  								// and p2 is a property of ancestor
     then cp1 has superPropName p2.  